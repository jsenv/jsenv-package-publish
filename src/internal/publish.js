import { exec } from "child_process"
import { resolveUrl, urlToFileSystemPath, readFile, writeFile } from "@jsenv/util"
import { setNpmConfig } from "./setNpmConfig.js"

export const publish = async ({
  logger,
  logNpmPublishOutput,
  projectDirectoryUrl,
  registryUrl,
  token,
}) => {
  try {
    const promises = []

    const previousValue = process.env.NODE_AUTH_TOKEN
    const restoreProcessEnv = () => {
      process.env.NODE_AUTH_TOKEN = previousValue
    }
    process.env.NODE_AUTH_TOKEN = token

    const projectPackageFileUrl = resolveUrl("./package.json", projectDirectoryUrl)
    const projectPackageString = await readFile(projectPackageFileUrl)
    const restoreProjectPackageFile = () => writeFile(projectPackageFileUrl, projectPackageString)
    const projectPackageObject = JSON.parse(projectPackageString)
    projectPackageObject.publishConfig = projectPackageObject.publishConfig || {}
    projectPackageObject.publishConfig.registry = registryUrl
    promises.push(
      writeFile(projectPackageFileUrl, JSON.stringify(projectPackageObject, null, "  ")),
    )

    const projectNpmConfigFileUrl = resolveUrl("./.npmrc", projectDirectoryUrl)
    let projectNpmConfigString
    try {
      projectNpmConfigString = await readFile(projectNpmConfigFileUrl)
    } catch (e) {
      if (e.code === "ENOENT") {
        projectNpmConfigString = ""
      } else {
        throw e
      }
    }
    const restoreProjectNpmConfigFile = () =>
      writeFile(projectNpmConfigFileUrl, projectNpmConfigString)
    promises.push(
      writeFile(
        projectNpmConfigFileUrl,
        setNpmConfig(projectNpmConfigString, {
          [computeRegistryTokenKey(registryUrl)]: token,
          [computeRegistryKey(projectPackageObject.name)]: registryUrl,
        }),
      ),
    )

    await Promise.all(promises)

    try {
      return await new Promise((resolve, reject) => {
        const command = exec(
          "npm publish",
          {
            cwd: urlToFileSystemPath(projectDirectoryUrl),
            stdio: "silent",
          },
          (error) => {
            if (error) {
              // publish conflict generally occurs because servers
              // returns 200 after npm publish
              // but returns previous version if asked immediatly
              // after for the last published version.

              // npm publish conclit
              if (error.message.includes("EPUBLISHCONFLICT")) {
                resolve({
                  success: true,
                  reason: "published",
                })
              }
              // github publish conflict
              else if (error.message.includes("ambiguous package version in package.json")) {
                resolve({
                  success: true,
                  reason: "published",
                })
              } else {
                reject(error)
              }
            } else {
              resolve({
                success: true,
                reason: "published",
              })
            }
          },
        )
        if (logNpmPublishOutput) {
          command.stdout.on("data", (data) => {
            logger.debug(data)
          })
          command.stderr.on("data", (data) => {
            // debug because this output is part of
            // the error message generated by a failing npm publish
            logger.debug(data)
          })
        }
      })
    } finally {
      await Promise.all([
        restoreProcessEnv(),
        restoreProjectPackageFile(),
        restoreProjectNpmConfigFile(),
      ])
    }
  } catch (e) {
    return {
      success: false,
      reason: e,
    }
  }
}

const computeRegistryTokenKey = (registryUrl) => {
  if (registryUrl.startsWith("http://")) {
    return `${registryUrl.slice("http:".length)}/:_authToken`
  }
  if (registryUrl.startsWith("https://")) {
    return `${registryUrl.slice("https:".length)}/:_authToken`
  }
  if (registryUrl.startsWith("//")) {
    return `${registryUrl}/:_authToken`
  }
  throw new Error(`registryUrl must start with http or https, got ${registryUrl}`)
}

const computeRegistryKey = (packageName) => {
  if (packageName[0] === "@") {
    const packageScope = packageName.slice(0, packageName.indexOf("/"))
    return `${packageScope}:registry`
  }
  return `registry`
}
